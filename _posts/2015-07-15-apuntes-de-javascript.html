---
layout: post
title: Apuntes de Javascript
date: '2015-07-15T02:00:00.003+02:00'
author: Pere Vilas
tags:
- javascript
modified_time: '2015-07-15T17:15:29.138+02:00'
blogger_id: tag:blogger.com,1999:blog-9191328551308072706.post-4026789240469614754
blogger_orig_url: http://www.pvilas.com/2015/07/apuntes-de-javascript.html
---

<h1 id="apuntes-de-javascript">Apuntes de Javascript</h1> <p>Traducción/resumen de <a href="https://github.com/stevekwan/best-practices/blob/master/javascript/gotchas.md">Common JavaScript “Gotchas”</a>. A mí me ha resultado útil para no terminar con una empanada monumental.</p> <h2 id="la-palabra-clave-var">La palabra clave <code>var</code></h2> <p><code>var</code> declara una variable y <strong>siempre debería usarse</strong> puesto que en otro caso la variable se declarará goblamente.</p> <blockquote>  <p>¡Siempre usar <strong>var</strong> para declarar variables!</p></blockquote> <h2 id="porqué-hay-tantas-formas-de-definir-una-función-cuáles-son-las-diferencias">¿Porqué hay tantas formas de definir una función? ¿Cuáles son las diferencias?</h2> <p>Encontraremos tres formas comunes de definir una función:</p> <pre class="prettyprint"><code class=" hljs javascript">myFunction1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1, arg2)</span> {</span>};     <span class="hljs-comment">// NEVER do this!</span><br /><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction2</span><span class="hljs-params">(arg1, arg2)</span> {</span>};       <span class="hljs-comment">// This is OK, but...</span><br /><span class="hljs-keyword">var</span> myFunction3 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1, arg2)</span> {</span>}; <span class="hljs-comment">// This is best!</span></code></pre> <p>La primera define la función y la asigna a una variable <strong>globalmente</strong>. Tal vez no es lo que deseamos.</p> <p>La segunda tiene el scope adecuado pero tenemos que tener en cuenta las closures.</p> <p>La tercera es la mejor ya que es sintácticamente consistente con el punto anterior y no pone la función en el scope global. Incluso podemos mejorarla con</p>   <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-keyword">var</span> myFunction5 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aDifferentName</span><span class="hljs-params">(arg1, arg2)</span> {</span>};<br /><br />console.log(myFunction5.name); <span class="hljs-comment">// logs "aDifferentName"</span></code></pre> <p>En este caso, <code>name</code> queda definido al nombre de la función lo que puede ser útil para hacer debug y mejora la claridad del código.</p>   <h2 id="la-palabra-clave-this-cómo-se-comporta">La palabra clave <code>this</code>: Cómo se comporta?</h2> <p>Generalmente, no es necesario usar <code>this</code> ya que no se comporta como en el resto de lenguajes OOP. En este sentido, es recomendable seguir el patrón <a href="https://github.com/stevekwan/experiments/blob/master/javascript/module-pattern.html">module</a>.</p> <p>La palabra clave <code>this</code> es un puntero al contexto de ejecución actual. Con un ejemplo se ve mejor:</p>   <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-keyword">var</span> myFunction = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span><br />{</span><br />    console.log(<span class="hljs-keyword">this</span>);<br />};<br /><span class="hljs-keyword">var</span> someObject = {};                <span class="hljs-comment">// Create an empty object.  Same as: new Object();</span><br />someObject.myFunction = myFunction; <span class="hljs-comment">// Give someObject a property</span><br />someObject.myFunction();            <span class="hljs-comment">// Logs Object</span><br />myFunction();                       <span class="hljs-comment">// Logs...Window?</span></code></pre> <p>La primera llamada logea el objeto someObject porque se ejecuta en el contexto de este. Sin embargo, en la segunda llamada <code>myFunction();</code>se ejecuta desde el contexto de la raiz del navegador y por eso logea el objeto `window’. </p> <blockquote>  <p>Lo importante es recordar que <code>this</code> apunta a lo que sea que haya “a la izquierda del punto”.</p></blockquote>   <h2 id="qué-demonios-es-una-closure">Qué demonios es una closure?</h2> <p>Es una característica del lenguaje que permite que una variable no se destruya si su valor podría ser requerido en el futuro. Esto es necesario en el manejo de eventos.</p> <p>Supongamos este código:</p>   <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-comment">// When someone clicks a button, show a message.</span><br /><span class="hljs-keyword">var</span> setup = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span><br />{</span><br />    <span class="hljs-keyword">var</span> clickMessage = <span class="hljs-string">"Hi there!"</span>;<br />    $(<span class="hljs-string">'button'</span>).click<br />    (<br />        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span><br />        {</span><br />            window.alert(clickMessage);<br />        }<br />    );<br />};<br />setup();</code></pre> <p>En un leguaje sin closures, lo más probable es que la variable clickMessage ya no existiera en el momento en que el usuario pulsara el botón. Pero Javascript “sabe” que debe mantener la variable.</p> <p>Pero es que aún podemos llegar un poco más lejos con algo como esto:</p>   <pre class="prettyprint"><code class=" hljs lisp"><span class="hljs-list">(<span class="hljs-title">function</span><span class="hljs-list">()</span><br />{<br />    var clickMessage = <span class="hljs-string">"Hi there!"</span><span class="hljs-comment">;</span><br />    $<span class="hljs-list">('button')</span>.click<br />    <span class="hljs-list">(<br />        function<span class="hljs-list">()</span><br />        {<br />            window.alert<span class="hljs-list">(<span class="hljs-title">clickMessage</span>)</span><span class="hljs-comment">;</span><br />        }<br />    )</span><span class="hljs-comment">;</span><br />})</span><span class="hljs-list">()</span><span class="hljs-comment">;</span></code></pre> <p>En este ejemplo ni siquiera tenemos que dar nombre a la función. Como quiera que hemos terminado el código con <code>()</code> se ejecutará una vez y ya podemos olvidarnos de él con la certeza de que todo lo declarado dentro existirá en el momento en que el usuario haga click.</p>