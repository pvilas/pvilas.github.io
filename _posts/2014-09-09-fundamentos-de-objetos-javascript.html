---
layout: post
title: Fundamentos de objetos javascript
date: '2014-09-09T02:00:00.003+02:00'
author: Pere Vilas
tags:
- javascript
modified_time: '2014-09-09T13:05:21.171+02:00'
blogger_id: tag:blogger.com,1999:blog-9191328551308072706.post-8124733448805975525
blogger_orig_url: http://www.pvilas.com/2014/09/fundamentos-de-objetos-javascript.html
---

<p>En javascript, la tarea de crear objetos se deja al programador el cuál escogerá la mejor estrategia según sus intereses.</p> <p>Javascript no es Java en el sentido de que es un leguaje <strong>basado</strong> en objetos donde estos son la entidad fundamental. Difiere de Java en que tiene su propia filosofía acerca de la creación y uso de objetos.</p> <p>Estas diferencias pueden causar problemas a los programadores que vienen de otros lenguajes y se <em>pierden</em> al intentar aplicar la misma filosofía que Java, o C++ a Javascript. En este sentido, la filosofía de JS se parece más a SmallTalk.</p> <h3 id="características-de-javascript">Características de javascript</h3> <p>Javascript <strong>no tiene</strong> ni clases ni tipos. En JS <strong>todo</strong> es un objeto (con las excepciones de <code>null</code> y <code>undefined</code>).</p> <p>Un <strong>objeto</strong> JS es un <strong>contenedor</strong> que puede contener una colección de otros objetos.</p>   <h4 id="primera-forma-de-crear-un-objeto">Primera forma de crear un objeto</h4> <p>El punto de partida es el objeto vacío <code>{}</code>. <code>{}</code>significa que es un objeto y puede contener otros objetos.</p> <p>Dentro de un objeto se pueden definir los miembros como nombre:objeto separados por una coma. Los nombres se conocen generalmente como las propiedades del objeto.</p> <p>Por ejemplo:</p>   <pre class="prettyprint"><code class="language-javascript hljs ">{<br />    prop1: object1, <br />    prop2: object2, <br />    prop3: {}<br />};</code></pre> <p>Nótese que <code>prop3</code> es el objeto vacío.</p> <h4 id="segunda-forma-de-crear-un-objeto">Segunda forma de crear un objeto</h4> <p><code>new Object();</code> tiene el mismo efecto (casi) que <code>{}</code>, i.e. crea un objeto vacío.</p> <h3 id="acceso-a-las-propiedades">Acceso a las propiedades</h3> <p>Tenemos dos métodos equivalentes para el acceso a las propiedades de un objeto:</p> <p><code>object.property;</code> <br> o <br> <code>object[property];</code></p> <p>La ventaja del segundo es que la propiedad puede ser un String y por lo tanto ser determinada dinámicamente. Por otra parte, la primera versión es más rápida por que se determina en tiempo de compilación.</p> <p>También podemos formar cadenas de propiedades como</p> <p><code>object.property1.property2;</code> <br> o <br> <code>object[property1][property2];</code></p>   <h3 id="asignar-el-valor-de-una-propiedad-o-crear-una-nueva-propiedad">Asignar el valor de una propiedad o crear una nueva propiedad</h3> <p><code>object.property1={}; // asignar</code> <br><code>object.property3={}; // crear y asignar una nueva propiedad</code></p> <p>Todos los objetos javascript son dinámicos y por lo tanto podemos crear nuevas propiedades en cualquier momento.</p>   <h2 id="la-variable-de-objeto-global">La variable de objeto global</h2> <p>Para poder usar las variables tenemos que tener un método para seguirles la pista una vez creadas. Pero en Javascript la idea de variable es un tanto sutil.</p> <blockquote>  <p>JavaScript proporciona un objeto estándar llamado global object</p></blockquote> <p>En general, este objeto global es llamado <strong>this</strong>, aunque si estamos ejecutando en un navegador es llamado <strong>window</strong>.</p> <blockquote>  <p><strong>Atención:</strong> this se refiere al objeto global siempre que esté fuera de una función.</p></blockquote> <p>Podemos crear propiedades de alcance (scope) global sencillamente dando propiedades a <strong>this</strong> fuera de una función:</p> <p><code>this.myObject={};</code></p>   <h4 id="diferentes-formas-de-crear-variables-globales">Diferentes formas de crear variables globales</h4> <ol><li><code>myObject={};</code></li><li><code>var myObject; myObject={};</code></li><li><code>var myObject={};</code></li></ol> <p>Todas ellas se traducen en  <br><code>this.myObject={};</code></p> <p>En Javascript no existen las variables globales, sólo propiedades del objeto global.</p> <blockquote>  <p>Recodar que this dentro de una función tiene un significado distinto.</p></blockquote> <h2 id="hoisting">Hoisting</h2> <p>Para hacer las cosas un poco más interesantes, hay una sutil diferencia entre:</p> <p><code>this.property=value;</code> <br>y <br><code>var property=value;</code></p> <p>La segunda versión en realidad hace que podamos usar property <strong>antes de ser declarada</strong>. La forma en que JS hace esto es muy sencilla:</p> <ol><li>Escanea todo el código en busca de declaraciones <code>var</code>.</li><li>Lleva automáticamente la declaración al principio del código con lo que todas las variables dentro del contexto quedan declaradas y por tanto podemos usarlas en cualquier punto del programa.</li><li>Cuando la ejecución llega a la línea <code>var property=value;</code> le asigna el valor.</li></ol> <h2 id="semántica-de-las-referencias-a-objetos">Semántica de las referencias a objetos</h2>   <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">var</span> myObject1={};<br /><span class="hljs-keyword">var</span> myObject2=myObject1;</code></pre> <p>Tanto <code>myObject1</code> como <code>myObject2</code> referencian exactamente al mismo objeto. Un cambio en uno será visible en el otro.</p>   <h2 id="objetos-que-vienen-con-el-lenguaje">Objetos que vienen con el lenguaje</h2> <p>Hay una serie de objetos que ya vienen con Javascript, uno de ellos es el objeto String.</p> <p><code>new String("Hola que tal");</code></p> <p>Crea un <strong>nuevo</strong> objeto cada vez que es llamado. Por ejemplo, podríamos tener un objeto tal como:</p> <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-built_in">var</span> myAddress<span class="hljs-subst">=</span>{<br />    Name: <span class="hljs-literal">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"Pere"</span>);<br />    Address: <span class="hljs-literal">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">"Eivissa"</span>);<br />};<br />console<span class="hljs-built_in">.</span><span class="hljs-keyword">log</span>(myAddress<span class="hljs-built_in">.</span>Name);<br />console<span class="hljs-built_in">.</span><span class="hljs-keyword">log</span>(myAddress<span class="hljs-preprocessor">[</span><span class="hljs-string">'Address'</span><span class="hljs-preprocessor">]</span><span class="hljs-markup">);</span></code></pre> <p>El objeto String es tan importante que podemos abreviar su creación llamando sencillamente a <br><code>alert('hola');</code> <br>en vez de  <br><code>alert(new String('hola'));</code></p> <p>Pero en realidad Javascript está usando la segunda versión en todo caso.</p> <h3 id="el-objeto-number">El objeto Number</h3> <p>Podemos usar tanto</p> <p><code>var num= new Number(3);</code></p> <p>como</p> <p><code>var num=3;</code></p> <p>Lo que ocurre es que la segunda versión está ligeramente optimizada (sería un tipo primitivo en otros lenguajes) pero en el mismo momento en que hacemos esto</p> <p><code>num.toString();</code></p> <p>Se convierte automáticamente al objeto Number.</p> <blockquote>  <p>No se pueden añadir propiedades a un objeto primitivo.</p></blockquote> <p>En cambio, podemos añadir nuevas propiedades al objeto Number sin mayor problema.</p>   <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">Number</span>.prototype.porDos=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span><br />        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>*<span class="hljs-number">2</span>;<br />};<br /><span class="hljs-keyword">var</span> num=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">3</span>);<br />console.log(num.porDos()); <span class="hljs-comment">// 6</span></code></pre> <h2 id="expresiones-e-inmutabilidad">Expresiones e inmutabilidad</h2> <p>Una expresión toma datos y los combina para producir nuevos datos.</p> <p><code>var res=2*3+4; // res=10</code></p> <p>pero</p>   <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-keyword">var</span> n1= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">2</span>);<br /><span class="hljs-keyword">var</span> n2= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">3</span>);<br />n2.age=<span class="hljs-number">13</span>;<br /><span class="hljs-keyword">var</span> n3=n1+n2;<br />console.log(n3); <span class="hljs-comment">// 5</span><br />console.log(n3.age); <span class="hljs-comment">// undefined</span></code></pre> <p>Esto ocurre porque las expresiones que combinan objetos siempre devuelven un nuevo objeto del tipo original (Number).</p>   <h4 id="disclaimer">Disclaimer</h4> <p>Esta entrada es resultado de apuntes tomados al vuelo leyendo la serie de artículos de javascript escrita por Ian Elliot en i-programmer. No pretende ser una traducción al español ni nada parecido, es un simple registro para mi uso personal. Debe referirse al original para su lectura.</p> <p>Fuente: <a href="http://www.i-programmer.info/programming/javascript.html">i-programmer.info</a> <br>Written with StackEdit.</p>