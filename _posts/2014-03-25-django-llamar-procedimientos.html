---
layout: post
title: Django llamar a procedimientos almacenados Oracle con parámetros de salida
date: '2014-03-25T13:22:00.000+01:00'
author: Pere Vilas
tags:
- django
- oracle
modified_time: '2014-03-25T13:29:23.036+01:00'
blogger_id: tag:blogger.com,1999:blog-9191328551308072706.post-5516229579856428504
blogger_orig_url: http://www.pvilas.com/2014/03/django-llamar-procedimientos.html
---

En el momento de escribir esto (1.6 de django) y después de darle varias vueltas, he llegado a la conclusión de que no es factible acceder al contenido de los parámetros de retorno sin usar directamente cx_Oracle, lo que en un momento dado puede repercutir en la portabilidad de la aplicación.<br /><br />Teniendo esto claro, se trata de diseñar una estrategia que nos permita usar toda la potencia de los procedimientos almacenados con el mínimo coste en caso de cambiar de gestor de base de datos.<br /><br />He intentado alejarme del estándar lo menos posible pero, como he comentado, no veo forma de librarse del uso directo de cx_Oracle. Esto es debido a las particularidades que presenta cada gestor a la hora de reservar espacio para las variables de salida en función del tipo. Por ello, lo que he hecho es escribir una función para cada tipo de parámetro de salida, por ejemplo,<br /><br /><br /><pre>from django.db import connection<br />import cx_Oracle<br /><br />def call_proc_str1(cadena, valors=None):<br /><br />&nbsp; &nbsp;""" llama a un procedimiento Oracle cuyo ultimo parámetro es un string de salida """&nbsp; &nbsp; cur = connection.cursor()<br /><br />&nbsp; &nbsp; # preparam cadena per a Oracle<br />&nbsp; &nbsp; cadena="BEGIN %s; END;;" % (cadena,)<br />&nbsp; &nbsp; # preparam el parametre de sortida<br />&nbsp; &nbsp; sortida=cur.cursor.var(cx_Oracle.STRING)<br />&nbsp; &nbsp; # afeixim paràmetre com a darrer<br />&nbsp; &nbsp; valors.append(sortida)<br />&nbsp; &nbsp; try:<br />&nbsp; &nbsp; &nbsp; &nbsp; cur.execute(cadena, valors)<br />&nbsp; &nbsp; &nbsp; &nbsp; # retornam paràmetre de sortida<br />&nbsp; &nbsp; &nbsp; &nbsp; return sortida.getvalue()<br />&nbsp; &nbsp; except Exception, e:<br />&nbsp; &nbsp; &nbsp; &nbsp; mensaje="%s Error: call_proc cadena#%s valors#%s" % (e, cadena, valors)<br />&nbsp; &nbsp; &nbsp; &nbsp; logger.error(mensaje)<br />&nbsp; &nbsp; &nbsp; &nbsp; raise Exception(mensaje)<br />&nbsp; &nbsp; finally:<br />&nbsp; &nbsp; &nbsp; &nbsp; cur.close()<br /></pre><br /><div>Se observan varios detalles:</div><div><ol><li>Hay que formar la cadena de la llamada como&nbsp;<span style="font-family: monospace; white-space: pre;">cadena="BEGIN %s; END;;" % (cadena,).</span><span style="white-space: pre;"><span style="font-family: Times, Times New Roman, serif;"> Es debido a la forma cómo se hace la llamada via execute.</span></span></li><li><span style="font-family: Times, 'Times New Roman', serif; white-space: pre;">Se crea y se reserva espacio para un string mediante cur.cursor.var(cx_Oracle.STRING) y se añade al final de los parámetros de conexión.</span></li><li><span style="font-family: Times, 'Times New Roman', serif; white-space: pre;">Extraemos el valor del parámetro mediante sortida.getvalue()</span></li></ol><br /> Para un procedimiento como este:<br /><br /><pre><span style="font-family: inherit;">create or replace procedure prueba(<br />&nbsp; param1 in varchar2,<br />&nbsp; param2 in varchar2,<br />&nbsp; param3 <b>out</b> varchar2) as .....<br /></span><br /><span style="font-family: Times, Times New Roman, serif;"><br /></span></pre>La llamada sería <br /><br /><pre>try:<br /><br />&nbsp; &nbsp; plsql="prueba(%s, %s, %s)"<br />&nbsp; &nbsp; param3=call_proc_str1(plsql, [param1, param2])<br />&nbsp; &nbsp; return jOk(param3)<br /><br />except Exception, ex:<br />&nbsp; &nbsp; return jErr(str(ex))<br /></pre><br /><div>Notar que usamos el placeholder %s de python-db en vez de el de Oracle. </div><div><br />En resumen; No es la mejor solución del mundo pero es fácil de portar si cambiamos de gestor de base de datos. </div></div>