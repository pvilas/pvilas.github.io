---
layout: post
title: Django modelo de datos genérico usando abstract
date: '2015-11-13T14:19:00.001+01:00'
author: Pere Vilas
tags:
- django
modified_time: '2015-11-17T18:39:22.615+01:00'
blogger_id: tag:blogger.com,1999:blog-9191328551308072706.post-6344448207954380564
blogger_orig_url: http://www.pvilas.com/2015/11/django-modelo-de-datos-generico-usando.html
---

Habitualmente, tenemos los mismos campos en varias tablas (modelos); Por ejemplo, la descripción, la fecha de alta, la fecha de última modificación, etc. Una forma de representar esto en los modelos es usar una clase genérica con los campos comunes y darle el atributo abstract. Las clases derivadas heredarán esos atributos.<br /><br />El la sincronización, Django no creará ninguna tabla en la base de datos si está marcada como abstract.<br /><br />En cuanto al nombre de la clave primaria del modelo, particularmente prefiero darle nombre en vez de dejar que Django la nombre como <i>id</i>.<br /><br />Hay que ir con cuidado derivando modelos: No es lo mismo una tabla (o una entidad) derivada que una vista. Por ejemplo, podríamos tener una entidad llamada Persona y otras derivadas llamadas Cliente, Proveedor, Agente, Transportista, etc. Si en Django derivamos esos modelos directamente de un modelo base (Persona), en la base de datos se crearán tantas tablas nuevas como modelos derivados (Clientes, Proveedores, ...). Esto no tiene nada que ver con tener una tabla llamada Persona y diversas vistas de esa única tabla llamadas Clientes, Proveedores, etc. En Django cada modelo equivale a una tabla (entidad), no a una vista. Para crear el equivalente a una vista debemos usar un QuerySet.<br /><br /><br /><br />```python<br /><br /># -*- coding: utf-8 -*-<br />from django.db import models<br /><br />LENGHT_DESC=150 # longitud de las descripciones<br />H_DESC = 'Entre descripción'<br /><br />def cPk():<br />&nbsp; &nbsp; # devuelve clave primaria<br />&nbsp; &nbsp; return models.AutoField(primary_key=True)<br /><br />def cFum():<br />&nbsp; &nbsp; # devuelve fecha ultima modificación<br />&nbsp; &nbsp; return models.DateTimeField(auto_now=True, null=False, blank=False)<br /><br />def cDesc(ml=LENGHT_DESC, df=''):<br />&nbsp; &nbsp; # devuelve descripción<br />&nbsp; &nbsp; return models.CharField(max_length=LENGHT_DESC, help_text=H_DESC, null=False, blank=False, default= df)<br /><br />def cFechaAlta():<br />&nbsp; &nbsp; # fecha de alta del registro<br />&nbsp; &nbsp; return models.DateTimeField(auto_now_add=True, null=False, blank=False)<br /><div><br /></div><br />class ModBase(models.Model):<br />&nbsp; &nbsp; #<br />&nbsp; &nbsp; # modelo base con descripcion, fecha de alta y fecha última modificación<br />&nbsp; &nbsp; #<br />&nbsp; &nbsp; descipcion=cDesc()<br />&nbsp; &nbsp; fecha_alta=cFechaAlta()<br />&nbsp; &nbsp; fum=cFum()<br /><div>&nbsp; &nbsp;</div><div>&nbsp; &nbsp; class Meta:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; abstract=True</div><div><br /></div><div><br /></div><div># esta tabla tendrá todos los campos de ModBase más&nbsp;los propios</div><div>class Personas(ModBase):</div><div>&nbsp; &nbsp; # el nombre de la clave primaria es persona</div><div>&nbsp; &nbsp; persona=cPk()</div><div><br /></div><div><br /></div><div>``` &nbsp; &nbsp;</div><br /><br />También podríamos usar la el modelo base para hacer un logger de los cambios en la base de datos, apuntando el nombre de la tabla, operación, usuario, etc.<br /><br />